I"K2<h3 id="overview">Overview</h3>

<p>For the summer of 2017 I wanted to look into developing a software synthesizer, possibly one that could be loaded as a VST plugin into music production software such as a Digital Audio Workstation (DAW). I decided to use JUICE for a few reasons, mainly becuase it focuses on code as opposed to virtual hardware and it appeared to have a pretty legitimate and large user base. However, attempting to get further into the nuts and bolts passed the tutorials quickly became quite challenging. In the end I gained a much better understanding of C++, gained a huge appreciation for how elaborate Audio software is, realized how complicated Synthesizers are, and created some neat applications. The last one I was able to do before school starting back up was an Additive Synthesizer with automatically Harmonized, yet toggle-able, harmonics.</p>

<p>Check out the Development Logs and take a look as I tought myself the advanced topics necessary,
laugh as I struggle through the nitty-gritty of troubleshooting EVERYTHING,
and follow along as the software development process unraveled.</p>

<p>As quickly as it came the summer ended, leaving me with a million more questions than answers. However, it also left me super hungry. I had an absolute blast teaching myself about audio programming, and can most definitely see myself loving to do it for the rest of my life. Between School, Work, my Internship at Awesome Inc, Lacrosse, my German Shepherd Puppy, and everything else going on in my life I am currently unable to get back into it, but I am really looking forward to the day I finally can. As I purchased my textbooks for the semester I also went ahead and bought “Designing Software Synthesizer Plug-Ins in C++: For RackAFX, VST3, and Audio Units” by Will Pirkle, which should be a really good guide for when the time comes for me to get back into it.</p>

<hr />

<h3 id="projects">Projects</h3>

<h4 id="1-chord-machine">1) Chord Machine:</h4>

<ul>
  <li>Barely got started</li>
  <li>Planned to Automatically play harmonic triads (major, minor, etc)</li>
  <li>List of Oscillator objects added together</li>
  <li>Split into multiple files for Oscillators, Interface, etc</li>
  <li>Toggle On/Off as well as control Volume &amp; Frequency for each Oscillator</li>
  <li>Control Main Volume</li>
</ul>

<h4 id="2-harmonic-synthesizer">2) Harmonic Synthesizer:</h4>

<ul>
  <li>List of Oscillator objects added together</li>
  <li>Split into multiple files for Oscillators, Interface, etc</li>
  <li>Automatically tunes subsequent oscillators to match the fundamental</li>
  <li>Toggle On/Off as well as control Volume &amp; Frequency for each Oscillator</li>
  <li>Control Main Volume</li>
</ul>

<h4 id="3-additive-synthesizer">3) Additive Synthesizer:</h4>

<ul>
  <li>List of Oscillator objects added together</li>
  <li>Split into multiple files for Oscillators, Interface, etc</li>
  <li>Toggle On/Off as well as control Volume &amp; Frequency for each Oscillator</li>
  <li>Control Main Volume</li>
</ul>

<h4 id="4-additive-manual">4) Additive Manual:</h4>

<ul>
  <li>Hardcoded a List of Oscillators and added them together</li>
  <li>Interface &amp; Processor in same files</li>
  <li>Toggle On/Off as well as control Volume &amp; Frequency for each Oscillator</li>
  <li>Control Main Volume</li>
</ul>

<h4 id="5-handlingmidi">5) HandlingMidi:</h4>

<ul>
  <li>Began attempting to handle midi signals</li>
  <li>Never tested with an actual MIDI controller</li>
</ul>

<h4 id="6-audiomanagementtemplate">6) AudioManagementTemplate:</h4>

<ul>
  <li>Where most of my time and energy got wasted</li>
  <li>Attemted to use the elaborate juce classes to handle the flow of audio</li>
  <li>See “Current Standing” of this blog post: https://brenthompson2.github.io/JUCE-Intro</li>
</ul>

<h4 id="7-firstsynth">7) FirstSynth:</h4>

<ul>
  <li>One oscillator</li>
  <li>Decent layout of the Interface</li>
  <li>Controls for Volume &amp; Frequency of that oscillator</li>
</ul>

<h4 id="8-myfirstplugin">8) MyFirstPlugin:</h4>

<ul>
  <li>Blank Audio Plugin project</li>
  <li>should be able to open it in a DAW but never tested</li>
</ul>

<h4 id="9-tutorial6tap">9) Tutorial6TAP:</h4>

<ul>
  <li>Followed along with a youtube tutorial creating and customizing sliders</li>
</ul>

<hr />

<h3 id="sample-code">Sample Code</h3>

<h4 id="oscillator">Oscillator</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void MainContentComponent::getNextAudioBlock (const AudioSourceChannelInfo&amp; bufferToFill)
{
    const int numChannels = bufferToFill.buffer-&gt;getNumChannels();
    const int numSamples = bufferToFill.numSamples;
    double originalAngle = currentAngle;
    // For Each Channel
    for (int channel = 0; channel &lt; numChannels; channel++){
        float* const buffer = bufferToFill.buffer -&gt; getWritePointer (channel, bufferToFill.startSample);
        currentAngle = originalAngle;
        updateAngleDelta();
        // For Each Sample
        for (int sample = 0; sample &lt; numSamples; sample++){
            // nextSample = (randomGen.nextFloat() * 2.0f - 1.0f); // For Randomly generated White Noise
            const float nextSample = (float) std::sin (currentAngle);
            currentAngle += angleDelta;
            buffer[sample] = nextSample * volumeLevel;
            if (!(sample % 100)) { std::cout &lt;&lt; buffer[sample] &lt;&lt; std::endl;}
        }
    }
}
</code></pre></div></div>

<p>This is the oscillator code from the <code class="highlighter-rouge">FirstSynth</code> project. Basically, the main object in JUCE calls this <code class="highlighter-rouge">getNextAudioBlock()</code> function constantly and passes it an audio buffer. For this oscillator implementation, the code goes through every channel and every sample and fills the buffer with <code class="highlighter-rouge">nextSample</code>. As can be seen in the commented out line, filling the buffer with random values generates white noise. In order to generate a Sine Wave, the buffer needs to be filled with values related to the change in the angle for each sample given the <code class="highlighter-rouge">currentFrequency</code>. This is managed in the <code class="highlighter-rouge">updateAngleDelta()</code> function below. As the projects got more advanced, the oscillator functions had to get exponentially more elaborate. For the synthesizers with multiple voices, the projects used an array of these components where each has its own member variables such as <code class="highlighter-rouge">angleDelta</code>, <code class="highlighter-rouge">currentFrequency</code>, <code class="highlighter-rouge">volumeLevel</code>, and many others.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void MainContentComponent::updateAngleDelta(){
    // number of cycles necessary per each output sample, multiplied by length of sine wave cycle (2pi radians)
    const double cyclesPerSample = currentFrequency / currentSampleRate;
    angleDelta = cyclesPerSample * 2.0 * double_Pi;
}
</code></pre></div></div>

<h4 id="drawing-the-ui">Drawing the UI</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void MainContentComponent::resized()
{
    Rectangle&lt;int&gt; area(getLocalBounds());
    // Header &amp; Footer Areas
    const int headerFooterHeight = 36;
    header.setBounds (area.removeFromTop (headerFooterHeight));
    footer.setBounds (area.removeFromBottom (headerFooterHeight));
    // Sidebar Area
    const int sidebarWidth = 80;
    sidebar.setBounds (area.removeFromLeft (sidebarWidth));
    // Content Area
    const int contentItemHeight = 80;
    Rectangle&lt;int&gt; contentOne(area.removeFromTop (contentItemHeight));
    Rectangle&lt;int&gt; contentTwo(area.removeFromTop (contentItemHeight));
    mainVolumeSlider.setBounds(contentOne.getX() + sidebarWidth, contentOne.getY(), contentOne.getWidth() - sidebarWidth, contentOne.getHeight()); // (getWidth() / 2) - 60, getHeight() / 2, 80, 100);
    frequencySlider.setBounds(contentTwo.getX() + sidebarWidth, contentTwo.getY(), contentTwo.getWidth() - sidebarWidth, contentTwo.getHeight()); // (getWidth() / 2) + 60, getHeight() / 2, 80, 100);
}
</code></pre></div></div>

<p>The JUCE framework has a fun method for drawing the interface. As can be seen in the snippet above from <code class="highlighter-rouge">FirthSynth</code>, basically each area is a rectangle subtracted from the entire screen area. Then each element simply sets its border boundaries relative to the areas that it is nested within. This <code class="highlighter-rouge">resized()</code> function is called automatically whenever the window is resized, which includes upon startup. The code bellow shows the dynamic redrawing of the content area for the <code class="highlighter-rouge">Harmonic Synth</code>. Each element in the <code class="highlighter-rouge">synthArray</code> gets drawn and automatically sets its bounds relative to the rectangles it creates relative to the other rectangles already within the elements.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Paint the Main Content Area
    const int contentItemHeight = 50;
    const int toggleBtnWidth = 40;
    for (int i = 0; i &lt; numActiveSynths; i++){
        Rectangle&lt;int&gt; tempSynthArea(area.removeFromTop (contentItemHeight));
        Rectangle&lt;int&gt; tempToggleArea(tempSynthArea.removeFromLeft (toggleBtnWidth));
        Rectangle&lt;int&gt; emptyContentArea(area.removeFromTop (contentItemHeight));
        // Set the Toggle Button Area
        (synthArray[i].toggleBtnArea).setPosition(tempToggleArea.getX(), tempToggleArea.getY());
        (synthArray[i].toggleBtnArea).setSize(tempToggleArea.getWidth(), tempToggleArea.getHeight());
        (synthArray[i].btnIsActive).setBounds((synthArray[i].toggleBtnArea).getX(), (synthArray[i].toggleBtnArea).getY(), (synthArray[i].toggleBtnArea).getWidth(), (synthArray[i].toggleBtnArea).getHeight());
        // Set The Volume Area
        (synthArray[i].volumeArea).setPosition(tempSynthArea.getX() + toggleBtnWidth, tempSynthArea.getY());
        (synthArray[i].volumeArea).setSize(tempSynthArea.getWidth() - toggleBtnWidth, tempSynthArea.getHeight());
        (synthArray[i].volumeSlider).setBounds((synthArray[i].volumeArea).getX() + sidebarWidth, (synthArray[i].volumeArea).getY(), (synthArray[i].volumeArea).getWidth() - sidebarWidth, (synthArray[i].volumeArea).getHeight());
        // Set The Frequency Area
        (synthArray[i].frequencyArea).setPosition(tempSynthArea.getX() + toggleBtnWidth, tempSynthArea.getY() + (contentItemHeight / 2));
        (synthArray[i].frequencyArea).setSize(tempSynthArea.getWidth() - toggleBtnWidth, tempSynthArea.getHeight());
        (synthArray[i].frequencySlider).setBounds((synthArray[i].frequencyArea).getX() + sidebarWidth, (synthArray[i].frequencyArea).getY(), (synthArray[i].frequencyArea).getWidth() - sidebarWidth, (synthArray[i].frequencyArea).getHeight());
    }
</code></pre></div></div>

<h4 id="listening-to-sliders">Listening to Sliders</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void MainContentComponent::sliderValueChanged (Slider* slider){
    if (slider == &amp;mainVolumeSlider){
       volumeLevel = mainVolumeSlider.getValue();
    }
    if (slider == &amp;frequencySlider){
        currentFrequency = frequencySlider.getValue();
        if (currentSampleRate &gt; 0.0){
            updateAngleDelta();
        }
    }
}
</code></pre></div></div>

<p>Again this code is from the <code class="highlighter-rouge">FirstSynth</code> project where there was only one oscillator. The code for handling changes in the UI sliders is actually quite simple thanks to the JUCE framework.</p>

<h3 id="development-logs">Development Logs</h3>

<p>I created detailed development logs during the whole process of learning. Check out <a href="https://github.com/brenthompson2/JUCE-Summer-Project/tree/master/The%20Development%20Logs">the Development Logs</a> and take a look as I tought myself the advanced topics necessary, laugh as I struggle through the nitty-gritty of troubleshooting EVERYTHING, and follow along as the software development process unraveled.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- It serves as a guide in case I ever need to redo any of the processes
- It is a notebook to review and reference while producing audio software
- There are summaries of research such as articles, tutorials, and videos that I can always reference
- Hopefully others may use this to guide their own research into Audio Plugin creation
- As a demonstration of my current ability and potential to grow
</code></pre></div></div>
:ET